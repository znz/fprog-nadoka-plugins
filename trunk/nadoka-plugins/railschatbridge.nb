# -*-ruby-*- vim:set filetype=ruby:
#
# Copyright (c) 2006 Kazuhiro NISHIYAMA
#
# This program is free software with ABSOLUTELY NO WARRANTY.
# You can re-distribute and/or modify this program under
# the same terms of the Ruby's lisence.
#
# $Id$
#
=begin

== Abstract

RailsChat bridge.

== Configuration

  BotConfig << {
    :name => :RailsChatBridge,
    :ch => '#nadoka_check',
    :connected_uri => 'http://localhost:3000/chat/login',
    :host => 'localhost',
    :port => 8080,
  }

=end

require 'open-uri'

class RailsChatBridge < Nadoka::NDK_Bot
  class ThreadStopper < Exception; end

  def bot_initialize
    unless @bot_config.key?(:ch)
      raise "must set :ch"
    end
    @listener_thread = nil
    ch = @bot_config[:ch]
    ch.sub!(/\A!/, '!dummy')
    @irc_channel = @config.canonical_channel_name(ch)
    @railschat_channel = @bot_config[:railschat_channel] || "chat_channel"
    @host = @bot_config[:host] || "localhost"
    @port = @bot_config[:port] || 8080
    @connected_uri = @bot_config[:connected_uri]

    check_threads
  end

  def bot_destruct
    begin
      if @ping_pong_thread
        @ping_pong_thread.raise ThreadStopper, "bot_destruct ping_pong_thread"
        @ping_pong_thread = nil
      end
    rescue Exception
    end
    begin
      if @listener_thread
        @listener_thread.raise ThreadStopper, "bot_destruct listener_thread"
        @listener_thread = nil
      end
    rescue Exception
    end
  rescue Exception
    @manager.ndk_error(e)
  end

  def check_threads
    if @listener_thread && @listener_thread.alive?
      return
    end
    @listener_thread = Thread.start do
      start_threads
    end
  end

  def start_threads
    sock = TCPSocket.open(@host, @port)
    sock.puts %Q!{"broadcast":0,"channels":["#{@railschat_channel}"]}!
    @logger.slog "RailsChatBridge: connected #{sock.inspect}"

    @ping_pong_thread = Thread.start do
      start_ping_pong_thread(sock)
    end

    open(@connected_uri){} if @connected_uri

    start_listener_thread(sock)
  rescue Exception => e
    @manager.ndk_error(e)
    begin
      if @ping_pong_thread
        @ping_pong_thread.raise ThreadStopper, "error stop ping_pong_thread"
        @ping_pong_thread = nil
      end
    rescue Exception
    end
    @ping_pong_thread = nil
    begin
      sock.close if sock
    rescue Exception
    end
  ensure
    @logger.slog "RailsChatBridge: teminate threads"
  end

  def start_ping_pong_thread(sock)
    @logger.slog "RailsChatBridge: start ping_pong_thread"
    while true
      sock.puts "\000"+'{"ping":1,"message":["9876543210FEDCBA"]}'
      sock.flush
      sleep 1
    end
  rescue ThreadStopper
    # ignore
  ensure
    @logger.slog "RailsChatBridge: terminate ping_pong_thread"
  end

  def start_listener_thread(sock)
    @logger.slog "RailsChatBridge: start listener_thread"
    while true
      buf = sock.gets("\000")
      buf.chomp!("\000")
      if /\A\{/ =~ buf
        bridge_on_json(buf)
      else
        bridge_on_msg_base64(buf)
      end
    end
  rescue ThreadStopper
    # ignore
  ensure
    @logger.slog "RailsChatBridge: terminate listener_thread"
  end

  def bridge_on_json(buf)
    if /"pong":1/ =~ buf
      # ignore pong
    else
      send_notice(@irc_channel, "RailsChatBridge: "+NKF.nkf('-Wj -m0', buf))
    end
  end

  def bridge_on_msg_base64(buf)
    msg = buf.unpack('m')[0]
    bridge_on_msg(msg)
  rescue Exception => e
    @manager.ndk_error(e)
  end

  def filter_msg!(msg)
    msg.gsub!(/<\/?strong>/, "\002")
    msg.gsub!(/<p>/, "\n")
    msg.gsub!(/<br \/>/, "\n")
    msg.gsub!(/<.+?>/, '')
    msg.strip!
    msg.gsub!(/[^\S\n]+/, ' ') # [\s] - [\n]
    msg
  end

  def bridge_on_msg(msg)
    msg.sub!(%r|\A<li class="comment" title="System \d+/\d+/\d+ \d+:\d+:\d+ #m" id="m">  <strong>System </strong>  <span> \d+:\d+:\d+ </span>  New User Connected! \(Active: \d+\)</li>\z|u) { filter_msg!($&) }
    msg.sub!(%r|\A<li class="comment"><strong>System </strong><span> \d+:\d+:\d+ </span> User Removed \(Active: \d+\)</li>\z|u) { filter_msg!($&) }
    msg.sub!(%r|<li (?:class="comment")? title="(.+?) \d+/\d+/\d+ \d+:\d+:\d+ #(m\d+)" id="\2">  <strong>\1 </strong>  <span>(<a href="/chat/show/\d+">)? \d+:\d+:\d+ (?:</a>)?</span>  .+</li>|u) { filter_msg!($&) }
    NKF.nkf('-Wj -m0', msg).each_line do |line|
      send_notice(@irc_channel, "RailsChatBridge: "+line)
    end
  end

  def on_timer(t)
    check_threads
  end

  def send_notice(ch, msg)
    chs = @manager.state.current_channels[ch]
    if chs
      rch = chs.name
    else
      rch = ch
    end
    super(rch, msg)
  end
end
